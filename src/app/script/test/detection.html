<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>test - detection.js</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #FFFFFF;
      overflow: hidden;
      width: 100%;
      height: 100%;
    }
    canvas {
      display: block;
      background: #FFFFFF;
    }
    #person-count {
      position: absolute;
      top: 0;
      left: 0;
      background-color: skyblue;
      color: white;
      font-size: 18px;
      font-weight: bold;
      padding: 6px 12px;
      border-bottom-right-radius: 8px;
      z-index: 10;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="person-count"></div>

  <script>
    // ライブラリ読み込みフラグ
    let libLoaded = false;
  </script>
  <script
    src="../detection.js"
    onload="libLoaded = true;"
    onerror="libLoaded = false; alert('ライブラリの読み込みに失敗しました。');">
  </script>

  <script>
    (async () => {
      const canvas = document.getElementById('canvas');
      const ctx    = canvas.getContext('2d');

      // オフスクリーン video 要素
      const video = document.createElement('video');
      video.autoplay    = true;
      video.muted       = true;
      video.playsInline = true;

      // カメラ起動
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        video.srcObject = stream;
        await video.play();
      } catch {
        alert('カメラの起動に失敗しました。');
        return;
      }

      // Canvas をウィンドウにフィット
      function resizeCanvas() {
        canvas.width  = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      window.addEventListener('resize', resizeCanvas);
      resizeCanvas();

      // 描画ループ（最大10fps）
      setInterval(async () => {
        if (video.readyState < 2) return;

        const cw = canvas.width;
        const ch = canvas.height;
        const vw = video.videoWidth;
        const vh = video.videoHeight;
        const canvasAR = cw / ch;
        const videoAR  = vw / vh;

        // 1. クリア
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, cw, ch);

        // 2. アスペクト比維持＋左右反転して動画を描画（cover）
        let sx = 0, sy = 0, sWidth = vw, sHeight = vh;
        if (videoAR > canvasAR) {
          // 元映像のほうが横長 → 横をクロップ
          sWidth = vh * canvasAR;
          sx = (vw - sWidth) / 2;
        } else {
          // 元映像のほうが縦長 → 縦をクロップ
          sHeight = vw / canvasAR;
          sy = (vh - sHeight) / 2;
        }

        ctx.save();
        // 左右反転
        ctx.translate(cw, 0);
        ctx.scale(-1, 1);
        // drawImage(映像, 切り取り開始 x,y, 切り取り幅,切り取り高さ, 描画先 x,y, 描画先幅,描画先高さ)
        ctx.drawImage(video,
                      sx, sy, sWidth, sHeight,
                      0,  0,  cw,      ch);
        ctx.restore();

        // 3. ライブラリ未読み込み／検出関数未定義なら完了
        if (!libLoaded || typeof detectFaces !== 'function') return;

        // 4. Face 検出
        let faces = [];
        try {
          const imageData = ctx.getImageData(0, 0, cw, ch);
          faces = await detectFaces(imageData);
        } catch {
          return;
        }
        if (!faces || faces.length === 0) return;

        // 5. 人物以外を白でマスク
        ctx.save();
        ctx.fillStyle = '#FFFFFF';
        ctx.globalCompositeOperation = 'destination-over';
        faces.forEach(face => {
          try {
            const bodyCoords = face.body();
            if (!bodyCoords || bodyCoords === false) return;
            ctx.beginPath();
            ctx.moveTo(bodyCoords[0][0], bodyCoords[0][1]);
            bodyCoords.forEach(p => ctx.lineTo(p[0], p[1]));
            ctx.closePath();
            ctx.fill();
          } catch {}
        });
        ctx.restore();

        // 6. 輪郭線の設定
        ctx.lineWidth = 2;

        faces.forEach(face => {
          // 顔輪郭（青）
          try {
            const contour = face.contour();
            if (contour && contour !== false) {
              ctx.strokeStyle = '#0000FF';
              ctx.beginPath();
              ctx.moveTo(contour[0][0], contour[0][1]);
              contour.forEach(p => ctx.lineTo(p[0], p[1]));
              ctx.closePath();
              ctx.stroke();
            }
          } catch {}

          // パーツ描画ヘルパー（赤）
          const drawPart = coords => {
            if (!coords || coords === false) return;
            ctx.strokeStyle = '#FF0000';
            ctx.beginPath();
            ctx.moveTo(coords[0][0], coords[0][1]);
            coords.forEach(p => ctx.lineTo(p[0], p[1]));
            ctx.closePath();
            ctx.stroke();
          };

          // 目
          try {
            const e = face.eyes();
            drawPart(e.left);
            drawPart(e.right);
          } catch {}

          // 鼻
          try { drawPart(face.nose()); } catch {}

          // 口
          try { drawPart(face.mouth()); } catch {}

          // 眉毛
          try {
            const eb = face.eyebrows();
            drawPart(eb.left);
            drawPart(eb.right);
          } catch {}

          // 涙袋
          try {
            const bags = face.eyebags();
            drawPart(bags.left);
            drawPart(bags.right);
          } catch {}
        });

        // 検出人数を表示
        document.getElementById('person-count').textContent = `人物: ${faces.length}人`;
      }, 100);
    })();
  </script>
</body>
</html>